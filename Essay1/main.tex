\documentclass[conference]{IEEEtran}
\usepackage{setspace}
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\doublespacing
\begin{document}

\title{Low-Code/No-Code Software Development\\
{\footnotesize \textsuperscript{}\textit{A look into the potential of using software to create software using little to no actual code}}
}

\author{\IEEEauthorblockN{Matthew Bevis}
\IEEEauthorblockA{\textit{Dept. of Computer Science} \\
\textit{Florida State University}\\
Tallahassee, FL, USA\\
mb19bo@my.fsu.edu}
}
\maketitle
\begin{abstract}
How is it that a program can be created without a human entering any code?  What could this mean for the future of software development?  Are there programs out there already built using this style of software development?
Will this be the end of the average software developer, or will such a thing not be able to scale into the future?  These questions will all be addressed below with a full analysis of where Low-code/No-code(LCNC) Software Development stands in the ever-changing world of computer science.
\end{abstract}

\section{Introduction}
To address the first question, low-code is almost exactly what it sounds like-- it is the next step in software evolution.  When the most basic computer was first invented, the only way that was conceivable to operate it was by using series of 1's and 0's to makeshift a control structure that in turn made it possible to run simple tasks precisely, given that the user writing the code knew what they were doing.  Shortly after, the next step toward more control was achieved with assembly code, although still far from being something that could merit a legitimate use at a basic functional level.  Through a series progression from binary, to assembly, then to FORTRAN, COBALT, C... eventually the "high-level" languages that exist today were reached and are now making lives easier every day\cite{OLP}.  In the following sections the motivation to build the next step in computer programming will be addressed, the general use cases of low-code development platforms(LCDPs), and the future of what could be interpolated from advancements to the process.
\section{Motivation}
The next step in the technological evolution is the step to the low-code application platform.  Low-code programming, although still crawling through the conceptual stages of development, consists of the idea that a program can be synthesized by using a something like a series of flow charts with rough bits of code, then once complete could be compiled into a fully working program. The time could be coming very soon where without even knowing any programming language, an individual could build an entire application from scratch using no code.  While there are basic versions of LCDPs that already exist, these ideas are still works in progress, although the benefits are far-reaching.  In fact, no-code development platforms(NCDPs) already exist, differing from LCDPs only in that no knowledge of any programming is necessary, only the requirements needed; by using general templates for application programming, businesses can create programs that allow them to do various sought after tasks at a rudimentary level with these development tools. A new age of entrepreneurship could soon be at hand as 'citizen developers'\cite{LCP} would have the power to create whatever application desired, without having to outsource to someone else's skill-set.  There are several kinds of of these LCDPs that also already exist, and have for some time.  These LCDPs function similarly to perform different tasks in aiding the user to construct code that does not require the added tedium of filling in control structures that the LCP can fill in.  At a basic level, even certain IDEs that auto-complete code statements can be considered a form of low-code processing.  The motivation behind being able to severely reduce the amount of time and effort that a project takes to reach a finished point should be clear.  The incentive for businesses is that time is money, and if a project can be shored up, the business can afford to focus on other areas that may need more immediate attention.  Software businesses like Oracle, Google, and IBM\cite{SDT} are already leading the way in the design and improvement of LCDPs, and for good reason.  As people become more comfortable with the idea of using these development tools, and companies like Oracle continue to improve how their function and security, more and more businesses are going to be eager to get their hands on them to increase productivity.
\section{Use Cases}
In relation to the existing LCDPs that are already available, not every LCDP requires the same design.  Although many work in very similar ways, the purpose of each is slightly unique, as there is no such way to have a one size fits all regarding the needs of different programming objectives in their current state.  For some, low-code is a solution to being able to quickly develop an application for intra-business control structures.  Taking IBM's Automation platform for example; IBM has plans to use their Automation platform, which makes use of machine learning and low-code, to automate reduce process blockers, i.e. arbitrary tasks that are relatively easy to perform, but time-consuming for the user.  The requirements for running such processes are limited in a functional sense, as by design, the user is meant to sit back, relax, and do the important work while the robotic process automation(RPA)\cite{LCP} takes care of the things that get in the way of the expedition of a task.  Functionally the user expects to be catered to, while on the non-functional side of things, the RPA should operate accordingly, and not interfere with the user's work\cite{RPA}.  Another design implementation of LCDPs is business process management(BPM)\cite{LCP}.  Again IBM is at the forefront of design implementation in these regard.  The basic idea is to keep track of the goings-on within the business, and record of employee actions, even scanning them to keep record of who is in the building and doing what.  This is not limited to the employees themselves, but also what is happening within systems.  This requires the program to functionally display information that may be deemed important to those who need to know in a seamless fashion, as well as give general records of various statistics also to be displayed.  On the back end, this requires a lot of processing power to be able to scan from building cameras, record information from devices on the network, all while maintaining optimal speeds and cyber-security\cite{BPM}.  One last example of implementation of LCDPs is that pertaining to rapid application development(RAD)\cite{LCP}.  This time, taking a look a different platform: Impact is a company that offers RAD.  RAD uses a templated design format to give business the application they need to help out their company.  From a functional perspective it is to be assumed that the program used to design the application will provide an interface for the customer to interact with, select a design scheme, and implement other needed facets of the application as needed by the customer.  Non-functionally, it is necessary that the application created will be secure, designed to the customers liking as per their selection, and implement all of the code necessary to create a functioning application.  Among the biggest applications of LCDPs, the most favored are rapid application development, business process management, and robotic process automation.  With these tools, operations can be monitored easily, tasks requiring tedious actions can be performed seamlessly, and quality applications can be developed.
\section{Future Work}
For the future of LCDPs and NCDPs the sky is the limit; over time more and more functionality is going to emerge that will catapult program development into the future.  Once a footing is established in this space, there is no telling what could not be achieved. LCDPs are already being tested with machine learning(ML), and although the current results of the attempts are a little lack-luster, the potential is there for ML to become an integral part of the design and implementation of programs going forward in combination with LCDPs and NCDPs\cite{AML}.  LCDPs and NCDPs are only going to improve going forward, making life for everyone a bit easier as programs become less of a grind dealing with control structures and implementation beyond the parts that matter to the customer, such as design interface.  According to a research study conducted by the research firm, Gartner, up to 65\% of software development could be implemented by using LCDPs\cite{XRM}, which is welcome news to those tech companies like IBM that are on the cutting edge of the design of these ingenious software development tools. 
\section{Conclusion}
In summation, low/no-code development platforms are just beginning to pick up speed, and soon enough they will be what is taught in the next college level courses, and could end up being what is used to design more than half of all programs globally.  The motivation for such tool is clear--to be able to design a program in minutes compared to hours is every software engineers' dream, although they may not want to give up what they know and love despite anyone being able to develop a high-level application with real-world applications. The most well known among LCDPs presently are rapid application development, business process management, and robotic process automation, which highlight the potential of low-code.  In light of the current limitations of LCDPs, it is not a stretch of imagination to believe that with proper implementation, they could hold the power to control existing data-structures and rapidly develop programs that are seamless and secure.  Eventually progress with low-code development may reach the point were no-code development is as easy as picking out clothes to wear, at which point the automation of just about anything could be possible. 
\bibliographystyle{ieeetr}
\bibliography{references}

\end{document}